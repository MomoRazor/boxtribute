type Box {
  id: ID!
  labelIdentifier: String!
  location: Location
  items: Int!
  product: Product!
  # A size from a size range, consider making this enum
  size: String
  state: BoxState!
  qrCode: QrCode!
  createdBy: User!
  createdOn: Datetime!
  # The user who last changed something about the box
  lastModifiedBy: User!
  lastModifiedOn: Datetime!
  comment: String
}

type QrCode {
  id: ID!
  code: String!
  box: Box
  createdOn: Datetime
}

type Product {
  id: ID!
  name: String!
  category: ProductCategory!
  sizeRange: SizeRange!
  sizes: [String!]!
  base: Base!
  price: Float
  gender: ProductGender
  createdBy: User!
  createdOn: Datetime!
  # The user who last changed something about the box
  lastModifiedBy: User!
  lastModifiedOn: Datetime!
}

type ProductCategory {
  id: ID!
  name: String!
  products(paginationInput: PaginationInput): ProductPage
  sizeRanges: [SizeRange]
  # Non-clothing categories don't have a product gender
  hasGender: Boolean!
}

type ProductPage {
  elements: [Product!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ProductGender {
  Men
  Women
  UnisexAdult
  UnisexKid
  UnisexBaby
  TeenGirl
  TeenBoy
  Girl
  Boy
  none
}

enum BoxState {
  InStock
  Lost
  MarkedForShipment
  Received
  Donated
  Scrap
}

type SizeRange {
  id: ID!
  label: String!
  sizes: [String!]!
  productCategory: [ProductCategory!]
}

type Location {
  id: ID!
  base: Base!
  name: String
  isShop: Boolean!
  # List of all the boxes in the location
  boxes(paginationInput: PaginationInput): BoxPage
  boxState: BoxState
  createdOn: Datetime
  # The user who generated QR code
  createdBy: User!
  lastModifiedBy: User!
  lastModifiedOn: Datetime!
}

type BoxPage {
  elements: [Box!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Base {
  id: ID!
  name: String!
  organisation: Organisation!
  locations: [Location!]
  beneficiaries(paginationInput: PaginationInput): BeneficiaryPage!
  currencyName: String
}

type Organisation {
  id: ID!
  name: String!
  bases: [Base!]
}

type User {
  id: ID!
  organisation: Organisation
  name: String
  email: String!
  validFirstDay: Date
  validLastDay: Date
  bases: [Base]
  lastLogin: Datetime
  lastAction: Datetime
}

type BeneficiaryPage {
  elements: [Beneficiary!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type Beneficiary {
  id: ID!
  firstName: String!
  lastName: String!
  dateOfBirth: Date!
  comment: String
  base: Base!
  groupIdentifier: String!
  gender: HumanGender!
  languages: [Language!]
  familyHead: Beneficiary
  isVolunteer: Boolean!
  isSigned: Boolean!
  isRegistered: Boolean!
  signature: String
  dateOfSignature: Date
  tokens: Int
  createdBy: User!
  createdOn: Datetime!
  lastModifiedBy: User!
  lastModifiedOn: Datetime!
}

type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

input CreateBoxInput {
  productId: Int!
  sizeId: Int
  items: Int!
  locationId: Int!
  comment: String!
  qrCode: String
}

input UpdateBoxInput {
  labelIdentifier: String!
  productId: Int
  sizeId: Int
  items: Int
  locationId: Int
  comment: String
}

input CreateBeneficiaryInput {
  firstName: String!
  lastName: String!
  baseId: Int
  groupIdentifier: String!
  dateOfBirth: Date!
  comment: String
  gender: HumanGender!
  languages: [Language!]
  familyHeadId: Int
  isVolunteer: Boolean!
  isRegistered: Boolean!
  signature: String
  dateOfSignature: Date
}

input UpdateBeneficiaryInput {
  id: ID!
  firstName: String
  lastName: String
  baseId: Int
  groupIdentifier: String
  dateOfBirth: Date
  comment: String
  gender: HumanGender
  languages: [Language!]
  familyHeadId: Int
  isVolunteer: Boolean
  isRegistered: Boolean
  signature: String
  dateOfSignature: Date
}

input PaginationInput {
  # PaginationInput must be either (first) OR (after, first) OR (before, last).
  # Indicate requesting paginating of the first X elements after cursor
  # cf. https://relay.dev/graphql/connections.htm#sec-Forward-pagination-arguments
  after: String
  first: Int
  # ... or the last X elements before cursor
  before: String
  last: Int
}

enum HumanGender {
  Male
  Female
  Diverse
}

enum Language {
  nl
  en
  fr
  de
  ar
  ckb
}

scalar Datetime
scalar Date

# all below is speculative #
type Order {
  id: ID!
  fromLocation: String!
  toLocation: String!
  # If null means internal transfer
  fromOrg: Int
  # If null means internal transfer
  toOrg: Int
  boxes: Box!
  # If box state of all ordered boxes have not yet been changed, then it is active
  isActive: Boolean!
  createdBy: User!
  createdOn: Datetime!
  lastModifiedBy: User
  # Need to change int to custom scalar for datetime
  lastModifiedOn: Int
}

type TransferAgreement {
  id: ID!
  sourceOrganisation: Organisation!
  targetOrganisation: Organisation!
  state: TransferAgreementState
  requestedBy: User!
  requestedOn: Datetime!
  acceptedBy: User
  acceptedOn: Datetime
  rejectedBy: User
  rejectedOn: Datetime
  canceledBy: User
  canceledOn: Datetime
  validFrom: Datetime!
  validUntil: Datetime
  sourceBases: [Base!]!
  targetBases: [Base!]
  shipments: [Shipment!]!
}

type Shipment {
  id: ID!
  sourceBase: Base
  targetBase: Base
  state: ShipmentState
  createdBy: User!
  createdOn: Datetime!
  sentBy: User
  sentOn: Datetime
  receivedBy: User
  receivedOn: User
  transferAgreement: TransferAgreement!
  details: [ShipmentDetail!]!
  lastModifiedBy: User!
  lastModifiedOn: Datetime!
}

type ShipmentDetail {
  id: ID!
  sourceProduct: Product!
  targetProduct: Product
  sourceLocation: Location!
  targetLocation: Location
  box: Box!
  shipment: Shipment!
  lastModifiedBy: User!
  lastModifiedOn: Datetime!
}

input TransferAgreementCreationInput {
  targetOrganisationId: Int!
  validFrom: Datetime
  validUntil: Datetime
  sourceBaseIds: [Int!]
}

input TransferAgreementUpdateInput {
  id: ID!
  validFrom: Datetime
  validUntil: Datetime
  sourceBaseIds: [Int!]
  targetBaseIds: [Int!]
}

input ShipmentCreationInput {
  sourceBaseId: Int!
  targetBaseId: Int!
  transferAgreementId: Int!
}

input ShipmentUpdateInput {
  id: ID!
  sourceBaseId: Int!
  targetBaseId: Int!
  # IDs of boxes prepared for shipment
  preparedBoxIds: [Int!]!
  # IDs of prepared boxes to be moved back to stock
  removedBoxIds: [Int!]!
  # IDs of boxes that went lost during shipment
  lostBoxIds: [Int!]!
}

input ShipmentDetailUpdateInput {
  id: ID!
  targetProductId: Int!
  targetLocationId: Int!
}

enum TransferAgreementState {
  UnderReview
  Accepted
  Rejected
  Canceled
  Expired
}

enum ShipmentState {
  Preparing
  Sent
  Completed
  Lost
  Canceled
}
